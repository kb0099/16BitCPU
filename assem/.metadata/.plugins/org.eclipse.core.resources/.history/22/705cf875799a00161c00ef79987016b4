package assem;

public class Instruction {

	// instructions are immutable
	final private Instr instruction; // 3 bits (except for MemType, which is 1 bit)

	public enum Instr {
		ADD,  SUB, AND,  OR,   XOR,  SLL, SRL, SRA,
		ADDI, CMP, ANDI, ORI,  XORI, LUI, LI,
		READ, WRITE,
		JL,   BEQ, BNE,  CALL, JR
	}

	public Instruction(Instr instruction) {
		this.instruction = instruction;
	}

	public Instr getInstruction() {
		return instruction;
	}

	public static String DecodeInstruction(Instr instruction) {
		switch(instruction) {
			case ADD: case ADDI: case READ : case JL : return "000";
			case SUB: case CMP : case WRITE: case BEQ: return "001";
			case AND: case ANDI: case BNE:  return "010";
			case OR : case ORI : case CALL: return "011";
			case XOR: case XORI: case JR  : return "100";
			case SLL: case LUI : return "101";
			case SRL: case LI  : return "110";
			case SRA: return "111";
			default: return "000";
		}
	}

	public static byte DecodeRegister(String register) {
		
		if (!register.startsWith("$")) {
			throw new IllegalArgumentException();
		}
		else {
			register = register.replace("$", ""); // remove $
		}
		
		
		switch (register) {
			case "zero":	return 0;
			case "ret":		return 12;
			case "sp":		return 13;
			case "ra":		return 14;
				
		}
		
		if (!register.matches("r[0-9]+")) {
			throw new IllegalArgumentException();
		}
		else {
			register = register.replace("r", ""); // remove r
			return Byte.parseByte(register); // all that's left is the number
		}
	}
	
	public static String ConvertRegToBinary(byte reg) {
		return String.format("%4s", Integer.toBinaryString(reg)).replace(' ', '0');
	}
	
	public static String ConvertImmToBinary(short imm, int width) {
		String format = "%" + width + "s";
		return String.format(format, Integer.toBinaryString(imm)).replace(' ', '0');
	}
	
	public static short ParseImmediate(String imm) {
		if (imm.startsWith("0x")) {
			return Short.parseShort(imm, 16);
		}
		else {
			Short.parseShort(imm, 10);
		}
		return 0;
	}
}