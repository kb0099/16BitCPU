package assem;

public class Instruction {

	// instructions are immutable
	final private Instr instruction; // 3 bits (except for MemType, which is 1 bit)

	public enum Instr {
		ADD,  SUB, AND,  OR,   XOR,  SLL, SRL, SRA,
		ADDI, CMP, ANDI, ORI,  XORI, LUI, LI,
		READ, WRITE,
		JL,   BEQ, BNE,  CALL, JR
	}

	/**
	 * Instruction Constructor
	 * @param instruction
	 */
	public Instruction(Instr instruction) {
		this.instruction = instruction;
	}

	/**
	 * Getter for instruction
	 * @return Instr enum
	 */
	public Instr getInstruction() {
		return instruction;
	}

	public static String DecodeInstruction(Instr instruction) {
		switch(instruction) {
			case ADD: case ADDI: case READ : case JL : return "000";
			case SUB: case CMP : case WRITE: case BEQ: return "001";
			case AND: case ANDI: case BNE:  return "010";
			case OR : case ORI : case CALL: return "011";
			case XOR: case XORI: case JR  : return "100";
			case SLL: case LUI : return "101";
			case SRL: case LI  : return "110";
			case SRA: return "111";
			default: return "000";
		}
	}

	/**
	 * Takes a register string (ex. $r1, $zero, etc.) and returns the 
	 * associated register number
	 * @param register
	 * @return byte the decoded register number
	 */
	public static byte DecodeRegister(String register) {
		String startingChar = "$";
		String regChar = "r";
		String regPattern = regChar + "[0-9]+";
		
		if (!register.startsWith(startingChar)) {
			throw new IllegalArgumentException("Registers must begin with a " + startingChar);
		}
		else {
			register = register.replace(startingChar, ""); // remove $
		}
		
		
		switch (register) {
			case "0":
			case "zero":	return 0;
			case "ret":		return 12;
			case "sp":		return 13;
			case "ra":		return 14;		
		}
		
		if (!register.matches(regPattern)) {
			throw new IllegalArgumentException("Register names must be either a "
					+ "special register name: zero, ret, sp, ra or of the form " + regPattern);
		}
		else {
			register = register.replace(regChar, ""); // remove r
			return Byte.parseByte(register); // all that's left is the number
		}
	}
	
	public static String ConvertRegToBinary(byte reg) {
		return String.format("%4s", Integer.toBinaryString(reg)).replace(' ', '0');
	}
	
	public static String ConvertImmToBinary(short imm, int width) {
		String format = "%" + width + "s";
		return String.format(format, Integer.toBinaryString(imm)).replace(' ', '0');
	}
	
	public static short ParseImmediate(String imm) {
		if (imm.startsWith("0x")) {
			return Short.parseShort(imm, 16);
		}
		else {
			Short.parseShort(imm, 10);
		}
		return 0;
	}
}