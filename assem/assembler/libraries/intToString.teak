# data segment is a list of pointers in .data memory which
# are null terminated to indicate the end of the array
# symbols here cannot start with $
.screen_init: tale_of_two_cities.txt # 128x64 = 8192

.glyph_init: ascii_8x8.png # 256x4 = 1024
# will need to load these into a register to access base address
.data
			#hello_world: "Hello World!" # null terminator will be added
			number: .size 6 # null terminator must be added by programmer

# converts a integer into a string.
# Returns a pointer to memory that is the start of the string
# Strings are null terminated
# ** need to define argument registers
# max integer value: (2^16)-1 = 65535

.teak # beginning of assembly code

# if (integer > 65536) “error”

# while (integer > 10000)
#	integer = integer - 10000;
#	ten_thousands++;
# don’t store leading zero’s
# … etc for other decimal places: 1000, 100, 10, 1

# charToStore = value + 48 # offset into decimal chars
# store into memory
# … do for each decimal place (don’t store leading zeros)
# store null terminator at the end

			# load 65535
			li    $r10, 65535
			comp $r0, $r10
			blteq cont
			li 		$ret, 99
			jl 		err
			# now throw error if greater than 65535?

			# load 10,000
cont: add  $r0, $r10
			li   $r10, 10000
			li   $r8, number # load number base address into $r8

			li 	 $r6, 0 # control variable
loop: li   $ret, 0 # zero out $ret

chck: comp  $r0,  $r10 # $r0 - $r10, $r0 <? 10000
			blteq done
			addi  $ret, 1    # +1 to return
			jl    chck

done:	add 	$r0, $r10 # restore $r0
			compi $ret, 0
			beq   case # if position is equal to zero, don't store the value
			addi  $ret, 48   # get ascii code
			write $ret, $r8, 0  # store ascii code into number address
			addi 	$r8, 1

case:	compi $r6, 0 # case structure to determine decimal position to work on
			beq   set_1k
			compi $r6, 1
			beq   set_100
			addi  $r6, 1
			compi $r6, 2
			beq   set_10
			addi  $r6, 2
			compi $r6, 3
			beq   set_1
			jl    finish

set_1k: li $r10, 1000
			jl loop

set_100: li $r10, 100
			jl loop

set_10: li $r10, 10
			jl loop

set_1: li $r10, 1
			jl loop

finish: li $ret number
err:
