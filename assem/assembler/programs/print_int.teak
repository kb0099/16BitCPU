# converts a number to a string and prints it to the screen

.screen_init: tale_of_two_cities.txt # 128x64 = 8192

.glyph_init: ascii_8x8.png # 256x4 = 1024

.data
			number: .size 6 # null terminator must be added by programmer

.teak # beginning of assembly code

			li 	 $a0, 32767 # number to convert to string (max signed val: 32767)
			li   $a1, number # load number base address into $a1
			
itos:	li   $t2, 10000
			li   $t0, 1 # leading zero? (boolean)
			li 	 $t1, 0 # control variable
itos_loop: li   $ret, 0 # zero out $ret

chk_pos: comp  $a0,  $t2 # $a0 - $t2, $a0 <=? $t2
			jlt  chk_done # use comp, jlt because in most cases will keep subtracted value
			addi 	$ret, 1
			jl 		chk

chk_done: add 	$a0, $t2 # restore $a0
			beqi  $t0, 0, store # check if base 10 position is leading zero and don't store if it is
			beqi  $ret, 0, dont_store
			li    $t0, 0
store: addi  $ret, 48   # get ascii code
			write $ret, $a1, 0  # store ascii code into number address
			addi 	$a1, 1	# increment mem address
dont_store:	addi  $t1, 1

   			 bnei $t1, 1, set_100 # case structure to determine decimal position to work on
			   li $t2, 1000
			   jl itos_loop
set_100: bnei $t1, 2, set_10
			   li $t2, 100
			   jl itos_loop
set_10:	 bnei $t1, 3, set_1
				 li $t2, 10
			 	 jl itos_loop
set_1:   bnei $t1, 4, itos_done
				 li $t2, 1
			   jl itos_loop 

itos_done: li $t0 number

			li    $a0, 0x1FFF   # VGA screen limit
			li    $a1, 0x0      # start at the beginning of text memory
			li    $t0, 0
clr:  write $t0, $a1, 0 # clear character
			beq  $a1, $a0, prnt # make sure doesn't clear past vga screen
			addi  $a1, 1        # increment to the next memory address
			jl    clr         	# repeat

prnt:	li    $t1, 0x0			# vga location to write to

ploop: read  $t2, $t0, 0 	# get char
			beqi  $t2, 0, end 	# if char is null pointer, finish
			write $t2, $t1, 0 	# write char to screen
			addi  $t0, 1 				# increment pointer address
			addi  $t1, 1 				# increment vga location
			jl    ploop
end: 	jl 		end						# hold program
