# converts a number to a string and prints it to the screen

.screen_init: tale_of_two_cities.txt # 128x64 = 8192

.glyph_init: ascii_8x8.png # 256x4 = 1024

.data
			number: .size 6 # null terminator must be added by programmer

.teak # beginning of assembly code

			li 	 $r1, 32767 # number to convert to string (max signed val: 32767)
			li   $r10, 10000
			li   $r8, number # load number base address into $r8

			li 	 $r6, 0 # control variable
loop: li   $ret, 0 # zero out $ret

chck: comp  $r1,  $r10 # $r1 - $r10, $r1 <=? $r10
			jlt  done
			addi 	$ret, 1
			jl 		chck

done: add 	$r1, $r10 # restore $r1
			addi  $ret, 48   # get ascii code
			write $ret, $r8, 0  # store ascii code into number address
			addi 	$r8, 1	# increment mem address

case:	beqi $r6, 0, set_1k # case structure to determine decimal position to work on
			beqi $r6, 1, set_100
			beqi $r6, 2, set_10
			beqi $r6, 3, set_1
			jl    finish

set_1k: li $r10, 1000
				addi $r6, 1
				jl loop

set_100: li $r10, 100
				 addi $r6, 1
				 jl loop

set_10: li $r10, 10
				addi $r6, 1
				jl loop

set_1: li $r10, 1
			 addi $r6, 1
			 jl loop

finish: li $r8 number

			li    $r1, 0x1FFF   # VGA screen limit
			li    $r2, 0x0      # start at the beginning of text memory
clr:  write $zero, $r2, 0 # clear character
			beq  $r2, $r1, prnt # make sure doesn't clear past vga screen
			addi  $r2, 1        # increment to the next memory address
			jl    clr         	# repeat

prnt:	li    $r9, 0x0			# vga location to write to

ploop:	read  $r10, $r8, 0 	# get char
			beqi $r10, 0, end 	# if char is null pointer, finish
			write $r10, $r9, 0 	# write char to screen
			addi  $r8, 1 				# increment pointer address
			addi  $r9, 1 				# increment vga location
			jl    ploop
end: 	jl 		end						# hold program
