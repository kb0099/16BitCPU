# prints a global string variable to the screen

.screen_init: init/main_screen.txt # 128x64 = 8192

.glyph_init: ascii_8x8_ext.png # 256x4 = 1024

.data 
			sp_start:  .const 0x4fff
			title: 		 .const 0xc1f	# title + 1*0x200 = menu_itm1, +2*0x200 = menu_itm2, etc.
			divider:   .const 0xf13 # divider + 1*0x200 = divider2, etc.
			cursor_start: .const 0xe1f # starts at first menu item
			cursor_pos:  0 # 0 = item0, 1 = item1, 2 = item2, 3 = item3
			screen:      0 # 0 = menu, 1 = info, 2 = current cond, 3 = historical report, 4 = game?
			hours:       0 # for global clock, min 1, max 12
			minutes:     0 # for global clock, min 0, max 59
			seconds:     0 # for global clock, min 0, max 59
			temperature: 0
			str_temperature: .size 4
			ptr_temperature: 0x0
			humidity:    0
			str_humidity: .size 4
			ptr_humidity: 0x0
			hist_data: {22, 23, 24, 20, 18, 20, 25, 27, 29, 30} # static data for now, size will eventually equal 39 (0-38)
			graph_pointer: 0x0
			btn_sw_ptr:    .const 0x4c00
			btn_up_mask:   .const 0x0001 #  1 = 0..0000 0001
			btn_rght_mask: .const 0x0002 #  2 = 0..0000 0010
			btn_dwn_mask:  .const 0x0004 #  4 = 0..0000 0100
			btn_lft_mask:  .const 0x0008 #  8 = 0..0000 1000
			btn_cntr_mask: .const 0x0010 # 16 = 0..0001 0000
			menu_title:     	 "      Menu"
			info_text: 				 "      Info"
			current_cond_text: "Current Conditions"
			hist_report_text:  "Historical Report"
			game_text: 				 "      Game?"
			temperature_text:	 "Temperature:  34°F"
			humidity_text:     "Humidity:     75 %"
			info1_text:        "Weather Station by"
			info2_text:        "E Oguz, T Dorney,"
			info3_text:        "K Bastakoti, &"
			info4_text:        "A Payne"
			menu_itm_text_len: .const 18
			menu_text_offset:  .const 494 # offset between menu text (last char to first char)
			menu_text_off_strt: .const 512 # (first char to first char)
			menu_itm_blank:    .const 0x20 # space
			blank_divider_r:   "´" # right divider character, vertical bar
			blank_divider_l:	 "¸" # left divider character, vertical bar
			blank_divider_c:   " " # center divider character, space
			line_divider_r:    "º" # right divider character, vertical bar w/ horizontal bar
			line_divider_l:    "¹" # left divider character, vertical bar w/ horizontal bar
			line_divider_c:    "»" # center divider character, horizontal bar
			divider_c_num:     .const 39  # number of center divider characters to draw
			divider_offset:    .const 472 # offset between dividers (last char to first char)
			blk_bg_white_fg:   .const 0x0F00
			blk_bg_h_red_fg:   .const 0x0C00
			blk_bg_h_blu_fg:   .const 0x0900
			blk_bg_h_grn_fg:   .const 0x0A00
			blk_bg_h_ylw_fg:   .const 0x0E00
			blk_bg_h_cyn_fg:   .const 0x0B00

.teak # beginning of assembly code

# main program entry point
main:		jal initialize

				li    $a0, blk_bg_h_red_fg
				jal   sh_cursor
				
				jal   wait1sec # wait 1 sec
				jal   draw_info
				jal   wait1sec # wait 1 sec
				jal   draw_menu
				jal   wait1sec # wait 1 sec
				
				li $a0, 1 # decrement cursor
				jal mov_cursor
				
				jal   wait1sec # wait 1 sec
				jal   draw_cond
				jal   wait1sec # wait 1 sec
				jal   draw_menu
				jal   wait1sec # wait 1 sec
				
				li $a0, 0 # cursor up
				jal mov_cursor
				
while:  jl main


# explicitly clears all registers and sets $sp. Also runs 
# the clk for ~65,000 cycles in order allow cpu to stabalize.
# arguments
#			none
# returns void
initialize: li $a0, 0
						li $a1, 0
						li $a2, 0
						li $s0, 0
						li $s1, 0
						li $s2, 0
						li $s3, 0
						li $t0, 0 
						li $t1, 0
						li $t2, 0
						li $t3, 0
						li $ret, 0
						li $sp, sp_start # initialize stack pointer address
						li $at, 0
						
						li $a0, 65000
init_loop:  beqi $a0, 0, init_done
						subi $a1, 1
						jl init_loop
init_done:  li $a0, 0
						jr $ra
						

# chk_scrn: check screen [state]
# checks what screen is currently displayed and calls the appropriate
# button checker
# arguments
#			none
# returns void						
chk_scrn: 	li   $t0, screen
						read $t2, $t0, 0 # get current screen state
						push $ra # save $ra away
						
						bnei $t2, 0, chk_info
						jal  chk_btns_menu
						jl   chk_scrn_done
chk_info:	  bnei $t2, 1, chk_cond
						#jal  chk_btns_info
						jl   chk_scrn_done
chk_cond:		beqi $t2, 2, chk_hist
						#jal  chk_btns_cond
						jl   chk_scrn_done
chk_hist:	  beqi $t2, 3, chk_scrn_done
						#jal  chk_btns_hist
chk_scrn_done:   pop  $ra
						jr   $ra
						

# chk_btns_menu: check button [states in] menu [screen]
# checks the state of the buttons while the menu screen is being displayed
# and performs the appropriate action depending on the current cursor
# position
# arguments
#			none 
# returns void					
chk_btns_menu: li $t0, btn_sw_ptr
						read $t1, $t0, 0 # get current state of btns
						push $ra
						
 						li  $t0, btn_cntr_mask # check center button first
	 					mov $t3, $t0 # keep mask around
						and $t3, $t1 # get state of center btn
						beq $t3, $t0, btn_c_mon
						
						li  $t0, btn_up_mask
						mov $t3, $t0 # keep mask around
						and $t3, $t1 # get state of center btn
						beq $t3, $t0, btn_up_mon
						
						li  $t0, btn_dwn_mask
						mov $t3, $t0 # keep mask around
						and $t3, $t1 # get state of center btn
						beq $t3, $t0, btn_dwn_mon
						jl  chk_btns_mdone
						
btn_c_mon:  li   $t2, cursor_pos
						read $t2, $t2, 0 # get cursor position
						bnei $t2, 0, btn_cmi
						jal draw_info
						jl  chk_btns_mdone
btn_cmi:    bnei $t2, 1, chk_btns_mdone
						jal draw_cond
						jl chk_btns_mdone

btn_up_mon: li $a0, 0 # increment cursor
						jal mov_cursor
						jl chk_btns_mdone
						
btn_dwn_mon: li $a0, 1 # decrement cursor
						jal mov_cursor				
						
chk_btns_mdone: pop $ra
						jr $ra
						
# chk_btns_other: check button [states in] other [screens]
# checks the state of the buttons while the other screens are being displayed. 
# this is primarily for any screen that only registers the "back" (left btn)
# press (which then draws the menu)
# arguments
#			none 
# returns void						
chk_btns_oth: li $t0, btn_sw_ptr
						read $t1, $t0, 0 # get current state of btns
						push $ra
						
 						li  $t0, btn_lft_mask # check center button first
	 					mov $t3, $t0 # keep mask around
						and $t3, $t1 # get state of center btn
						beq $t3, $t0, btn_l_oon
						jl  chk_btns_odone
						
btn_l_oon:  jal draw_menu				
						
chk_btns_odone: pop $ra
						jr $ra


# sh_cursor: show/hide cursor
# colors the text at the current cursor position with style $a0
# arguments
#			$a0 style with which to color cursor
# returns void
sh_cursor:   mov   $a2, $a0 # put cursor style in proper reg
						 li    $t0, cursor_pos
						 read  $t1, $t0, 0 # get cursor position
						 li    $a0, cursor_start # address of first cursor position 
						 li    $t3, menu_text_off_strt
cursor_loop: beqi  $t1, 0, color_cursor
						 add   $a0, $t3 # go to next cursor position
						 subi  $t1, 1
						 jl    cursor_loop
color_cursor: li   $a1, menu_itm_text_len # number of chars to highlight
						 push  $ra
						 jal   style_n_chars # color cursor
						 pop   $ra
						 jr 	 $ra


# mov_cursor: move cursor (up or down)
# increments or decrements the cursor position. keeps cursor from
# incrementing/decrementing too far. Also handles clearing style on current
# cursor position and updating next cursor position
# arguments
#			$a0 decrement? (boolean indicating 0 = increment or 1 = decrement)
# returns void
mov_cursor: mov  $s0, $a0 # save decrement
						li   $a0, blk_bg_white_fg
						push $ra
						jal  sh_cursor # hide current cursor
						li   $t0, cursor_pos
						read $t1, $t0, 0 # get cursor position
						beqi $s0, 0, decr
						beqi $t1, 3, wrap_to_strt
						addi $t1, 1
						jl   movc_fin
decr:				beqi $t1, 0, wrap_to_end
						subi $t1, 1
						jl   movc_fin
wrap_to_strt: li $t1, 0
						jl   movc_fin
wrap_to_end: li  $t1, 3
movc_fin:   write $t1, $t0, 0
						li   $a0, blk_bg_h_red_fg
						jal  sh_cursor
						pop  $ra
						jr  $ra

# draw_menu
# draws the first menu screen
# arguments
#			none
# returns void
draw_cond: li    $a0, menu_text_offset # menu_text_offset
				li    $a1, title # starting with title
				li    $a2, 5 # clear 5 menu items
				push  $ra
				jal 	clr_menu_text
				
				# clear dividers
				li    $a0, divider_offset
				li    $a1, divider
				li    $a2, 3 # clear 3 dividers
				li    $t0, blank_divider_l
				li    $t1, blank_divider_c
				li    $t2, blank_divider_r
				push  $t0
				push  $t1
				push  $t2
				jal 	draw_dividers

				li    $s0, blk_bg_white_fg # style
				li    $s1, title # location to start drawing
				li    $s2, menu_text_off_strt # offset between menu items (first char to first char)
				li    $s3, 0 # counter
				li    $t1, current_cond_text # title string
				
cond_loop: mov $a0, $t1 # pass text to print
				mov   $a1, $s1 # pass position to print to
				mov 	$a2, $s0 # pass style (black bg, white fg)
				jal 	prnt
				add   $s1, $s2 # increment position
				addi  $s3, 1   # increment counter
				
        bnei  $s3, 1, cond2
				li    $t1, temperature_text
				add   $s1, $s2 # skip first item slot
				jl    cond_loop
cond2:	bnei  $s3, 2, cond_done
				li    $t1, humidity_text
				jl    cond_loop				
				
cond_done: li $t0, screen # address of screen counter
				li    $t1, 2 # set screen state to current conditions
				write $t1, $t0, 0 # set screen counter to 0
				pop   $ra
				jr    $ra


# draw_menu
# draws the first menu screen
# arguments
#			none
# returns void
draw_menu: li    $a0, menu_text_offset # menu_text_offset
				li    $a1, title # starting with title
				li    $a2, 5 # clear 5 menu items
				push  $ra
				jal 	clr_menu_text
				
				li    $a0, divider_offset
				li    $a1, divider
				li    $a2, 3 # draw 3 dividers
				li    $t0, line_divider_l
				li    $t1, line_divider_c
				li    $t2, line_divider_r
				push  $t0 # extra args go on stack
				push  $t1
				push  $t2
				jal 	draw_dividers
				
				li 		$s0, blk_bg_white_fg
				li    $s1, title
				li    $s2, menu_text_off_strt
				li    $s3, 0 # counter
				li    $t1, menu_title
				
menu_loop: mov $a0, $t1 # pass text to print
				mov   $a1, $s1 # pass position to print to
				mov 	$a2, $s0 # pass style (black bg, white fg)
				jal 	prnt
				add   $s1, $s2 # increment position
				addi  $s3, 1   # increment counter
				
        bnei  $s3, 1, menu2
				li $t1, info_text
				jl menu_loop
menu2:	bnei  $s3, 2, menu3
				li $t1, current_cond_text
				jl menu_loop			
menu3:	bnei  $s3, 3, menu4
				li $t1, hist_report_text
				jl menu_loop
menu4:	bnei  $s3, 4, menu_done
				li $t1, game_text
				jl menu_loop				
				
menu_done: li $t0, screen # address of screen counter
				li    $t1, 0
				write $t1, $t0, 0 # set screen counter to 0
				li    $a0, blk_bg_h_red_fg
				jal   sh_cursor
				pop $ra
				jr $ra


# draw_info
# draws the info screen
# arguments
#			none
# returns void
draw_info: li    $a0, menu_text_offset # menu_text_offset
				li    $a1, title # starting with title
				li    $a2, 5 # clear 5 menu items
				push  $ra
				jal 	clr_menu_text
				
				li    $a0, divider_offset
				li    $a1, divider
				li    $a2, 3 # clear 3 dividers
				li    $t0, blank_divider_l
				li    $t1, blank_divider_c
				li    $t2, blank_divider_r
				push  $t0
				push  $t1
				push  $t2
				jal 	draw_dividers

				li    $s0, blk_bg_h_red_fg
				li    $s1, title
				li    $s2, menu_text_off_strt
				li    $s3, 0 # counter
				li    $t1, info_text
				
				# print info title
info_loop: mov $a0, $t1 # pass text to print
				mov   $a1, $s1 # pass position to print to
				mov 	$a2, $s0 # pass style (black bg, white fg)
				jal 	prnt
				add   $s1, $s2 # increment position
				addi  $s3, 1   # increment counter
				
        bnei  $s3, 1, info2
				li $s0, blk_bg_h_blu_fg
				li $t1, info1_text
				jl info_loop
info2:	bnei  $s3, 2, info3
				li $s0, blk_bg_h_grn_fg
				li $t1, info2_text
				jl info_loop			
info3:	bnei  $s3, 3, info4
				li $s0, blk_bg_h_ylw_fg
				li $t1, info3_text
				jl info_loop
info4:	bnei  $s3, 4, info_done
				li $s0, blk_bg_h_cyn_fg
				li $t1, info4_text
				jl info_loop				
				
info_done: li $t0, screen # address of screen counter
				li $t1, 1
				write $t1, $t0, 1 # set screen counter to 0
				pop $ra
				jr $ra


# wait
# waits the specified time where $a0 is the outer loop max value 
# and $a1 is the inner loop max value
# arguments
#			$a0 inner loop max value
#			#a1 outer loop max value
# returns void
wait:   li    $t1, 0 # inner loop counter
oreset:	li    $t0, 0 # outer loop counter
oloop:	addi  $t0, 1
				beq  $t0, $a0, iloop # if $t0 == $a0 then increment inner loop
				jl    oloop # loop


iloop:	addi  $t1, 1
				beq  $t1, $a1, wait_done
				jl    oreset
wait_done: jr $ra

# wait1sec: wait 1 second
# arguments
#			none
# returns void
wait1sec: li 	$a0, 65000 # outer loop limit, 65000*150 ~= 1 sec wait
				li 		$a1, 300 # inner loop limit
				li    $t1, 0 # inner loop counter
w1oreset: li  $t0, 0 # outer loop counter
w1oloop: addi $t0, 1
				beq   $t0, $a0, iloop # if $t0 == $a0 then increment inner loop
				jl    oloop # loop


w1iloop: addi $t1, 1
				beq  $t1, $a1, wait_done
				jl   oreset
wait1_done: jr $ra


# clr_menu_text: clear menu text
# takes pointer to first menu item ($a1), offset between menu items ($a0),
# and number of menu items to clear ($a2) and clears it with menu_itm_text_len 
# of menu_itm_blank's
# arguments
#			$a0 offset between menu items (last char to first char)
#			$a1 first menu item to clear
#			$a2 number of menu items to clear
# returns void
clr_menu_text: li $s2, 0
							 mov $s0, $a0 # offset
							 mov $s1, $a2 # menu items to clear
clr_menu_loop: blt $s2, $s1, clr_menu_item
							 jr $ra
clr_menu_item: li $a0, menu_itm_blank
							 li $a2, menu_itm_text_len # const
							 push $ra # store $ra on stack
							 jal prnt_n_chars
							 pop $ra # restore $ra off stack
							 add $a1, $s0
							 addi $s2, 1
							 jl clr_menu_loop


# draw_dividers
# takes pointer to first divider ($a1), offset between dividers ($a0), 
# and number of dividers to draw ($a2) and draws left ($sp+2), center ($sp+1)
# and right ($sp) dividers
# arguments
#			$a0   offset between dividers (last char to first char)
#			$a1   pointer to first dividers
#			$a2   number of dividers to draw
#			$sp   pointer to right divider character
#			$sp+1 pointer to center divider character
#			$sp+2 pointer to left divider character
# returns void
draw_dividers: mov  $s0, $a0 # save args, $s0 = offset between dividers
							mov   $s1, $a2 # $s1 = number of dividers to draw
							pop   $s2 # right divider
							pop   $s3 # center divider
							pop   $t0 # left divider
draw_div_loop: bnei  $s1, 0, draw_div
							jr    $ra
draw_div:     read  $t1, $t0, 0
							write $t1, $a1, 0 # draw left divider
							addi  $a1, 1 # increment vga screen pointer + 1
							read  $a0, $s3, 0
							li    $a2, divider_c_num # num of chars to print
							push  $ra
							push  $t0
							jal   prnt_n_chars
							pop   $t0
							pop   $ra
							read  $t1, $s2, 0
							write $t1, $a1, 0
							add   $a1, $s0 # move vga pointer to next divider
							subi  $s1, 1 # decrement dividers drawn so far
							jl    draw_div_loop


# prnt_n_chars: print n characters
# prints the specified char ($a0) n times ($a2) to the vga screen 
# starting at the position pointed to by $a1
# arguments
#			$a0 char to print
#			$a1 vga screen position to print char
#			$a2 number of chars to print in a row
# returns void
prnt_n_chars:	bnei  $a2, 0, prnt_char
							jr    $ra
prnt_char:    write $a0, $a1, 0
							subi  $a2, 1 # decrement chars to print
							addi  $a1, 1 # print to the next location
							jl    prnt_n_chars


# prnt: print
# prints string pointed to at $a0 to vga screen at location $a1
# with style $a2. Strings should be null terminated to prevent printing forever!
# arguments
#			$a0 string to print (pointer to first char)
#			$a1 vga screen location to print to
#			$a2 style to apply to string
# returns void
prnt:			 read  $t2, $a0, 0 	# get char
					 beqi  $t2, 0, prnt_done # if char is null pointer, finish
					 li    $t3, 0x00FF
					 and   $t2, $t3     # clear previous style
					 or    $t2, $a2		  # apply new style 
					 write $t2, $a1, 0 	# write char to screen
					 addi  $a0, 1 				# increment pointer address
					 addi  $a1, 1 				# increment vga location
					 jl    prnt
prnt_done: jr 	 $ra


# style_n_chars: style n characters
# applys the style provided in $a2 to the string pointed to by $a0
# for the number of characters specified in $a1. This proc is meant to be used
# to dynamically style characters already on screen but can be used for any 
# character set stored anywhere in memory
# arguments
#			$a0 pointer to first char to which to apply style
#			$a1 number of characters to style
#			$a2 style to apply
# returns void
style_n_chars: beqi $a1, 0, style_done
					 read  $t0, $a0, 0 # get char
					 li    $t2, 0x00FF
					 and   $t0, $t2     # clear previous style
					 or    $t0, $a2 # apply style
					 write $t0, $a0, 0 # write char to screen
					 subi  $a1, 1 # subtract num of chars to style
					 addi  $a0, 1 # increment to next char
					 jl    style_n_chars
style_done: jr   $ra


# make_style
# makes a char style given a blink ($a0), bg color ($a1), and fg color ($a2)
# arguments
#			$a0 blink (0 = no blink, 1 = blink)
#			$a1 background color (3 bit)
#     $a2 foreground color (4 bit)
# returns style (upper 8 bits of $ret set per $a0, $a1, $a2)
make_style: slli $a0, 3
						or   $a0, $a1  # combine blink with bg color
						slli $a0, 4
						or	 $a0, $a2  # combine blink, bg with fg color
						slli $a0, 8    # shift style to upper bits
						mov  $ret, $a0 # set return reg
						jr   $ra
								
						
# itos: integer to string
# converts an integer value ($a0) into a string, pointed at by $a1
# arguments. Note that the max value that can be converted is (2^15)-1
#			$a0 integer to convert into a string
#			$a1 pointer to string to store converted integer
# returns void						
itos:	li   $t2, 10000 # $t2 = decimal position current converting
			li   $t0, 1 # assume leading zero to begin with
			li 	 $t1, 0 # control variable
itos_loop: li   $ret, 0 # zero out $ret

chk_pos: comp  $a0,  $t2 # $a0 - $t2, $a0 <=? $t2
			jlt  chk_done # use comp then jlt because in most cases will keep subtracted value
			addi 	$ret, 1
			jl 		chk_pos

chk_done: add 	$a0, $t2 # restore $a0
			beqi  $t0, 0, store # check if base 10 position is leading zero and don't store if it is
			beqi  $ret, 0, dont_store
			li    $t0, 0
store: addi  $ret, 48   # get ascii code
			write $ret, $a1, 0  # store ascii code into number address
			addi 	$a1, 1	# increment mem address
dont_store:	addi  $t1, 1

# case structure to determine decimal position to work on
   			 bnei $t1, 1, set_100 
			   li $t2, 1000
			   jl itos_loop
set_100: bnei $t1, 2, set_10
			   li $t2, 100
			   jl itos_loop
set_10:	 bnei $t1, 3, set_1
				 li $t2, 10
			 	 jl itos_loop
set_1:   bnei $t1, 4, itos_done
				 li $t2, 1
			   jl itos_loop 

itos_done: jr $ra


# ctof: celcius to farenheit
# converts the given celcius value ($a0) into farenheit. Approximate value returned,
# because floating point multiplication is unsupported. Instead a bit shift
# by 1 (*2) is used rather than a multiplication by 1.8.
# arguments
#			$a0 celcius value to converts
# returns farenheit value
ctof: slli $a0, 1
			addi $a0, 32
			mov  $ret, $a0
			jr   $ra
