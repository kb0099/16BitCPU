# prints a global string variable to the screen

.screen_init: init/main_screen.txt # 128x64 = 8192

.glyph_init: ascii_8x8_ext.png # 256x4 = 1024

.data
			title: 		 .const 0xc1f	# title + 1*0x200 = menu_itm1, +2*0x200 = menu_itm2, etc.
			divider:   .const 0xf13 # divider + 1*0x200 = divider2, etc.
			menu_title:     	 "      Menu"
			info_text: 				 "      Info"
			current_cond_text: "Current Conditions"
			hist_report_text:  "Historical Report"
			game_text: 				 "      Game?"
			temperature_text:	 "Temperature: 34°F"
			humidity_text:     "Humidity: 75%"
			info1_text:        "Weather Station by"
			info2_text:        "E Oguz, T Dorney,"
			info3_text:        "K Bastakoti, &"
			info4_text:        "A Payne"
			menu_itm_text_len: .const 18
			menu_text_offset:  .const 494 # offset between menu text (last char to first char)
			menu_text_off_strt: .const 512 # (first char to first char)
			menu_itm_blank:    " "
			blank_divider_r:   "´" # right divider character, vertical bar
			blank_divider_l:	 "¸" # left divider character, vertical bar
			blank_divider_c:   " " # center divider character, space
			line_divider_r:    "º" # right divider character, vertical bar w/ horizontal bar
			line_divider_l:    "¹" # left divider character, vertical bar w/ horizontal bar
			line_divider_c:    "»" # center divider character, horizontal bar
			divider_c_num:     .const 39  # number of center divider characters to draw
			divider_offset:    .const 472 # offset between dividers (last char to first char)
			blk_bg_white_fg:   .const 0x0F00
			blk_bg_h_red_fg:   .const 0x0C00
			blk_bg_h_blu_fg:   .const 0x0900
			blk_bg_h_grn_fg:   .const 0x0A00
			blk_bg_h_ylw_fg:   .const 0x0E00
			blk_bg_h_cyn_fg:   .const 0x0B00

.teak # beginning of assembly code

# main program entry point
main:		li 		$sp, 20479 # initialize stack pointer address
				li 		$a0, 65000 # outer loop limit, 65000*150 ~= 1 sec wait
				li 		$a1, 300 # inner loop limit
				jal   wait # wait 1 sec, per arguments above
				
				li    $a0, menu_text_offset # menu_text_offset
				li    $a1, title # starting with title
				li    $a2, 5 # clear 5 menu items
				jal 	clr_menu_text
				
				li    $a0, divider_offset
				li    $a1, divider
				li    $a2, 3 # clear 3 dividers
				li    $t0, blank_divider_l
				li    $t1, blank_divider_c
				li    $t2, blank_divider_r
				push  $t0
				push  $t1
				push  $t2
				jal 	draw_dividers
				
				jal   draw_info
				
				li 		$a0, 65000 # outer loop limit, 65000*150 ~= 1 sec wait
				li 		$a1, 300 # inner loop limit
				jal   wait # wait 1 sec, per arguments above
				
				li    $a0, menu_text_offset # menu_text_offset
				li    $a1, title # starting with title
				li    $a2, 5 # clear 5 menu items
				jal 	clr_menu_text
				
				li    $a0, divider_offset
				li    $a1, divider
				li    $a2, 3 # draw 3 dividers
				li    $t0, line_divider_l
				li    $t1, line_divider_c
				li    $t2, line_divider_r
				push  $t0
				push  $t1
				push  $t2
				jal 	draw_dividers
				
				jal draw_menu
				
hold:   jl main

draw_menu: li $s0, blk_bg_white_fg
				li    $s1, title
				li    $s2, menu_text_off_strt
				li    $s3, 0 # counter
				li    $t1, menu_title
				push  $ra
				
menu_loop: mov $a0, $t1 # pass text to print
				mov   $a1, $s1 # pass position to print to
				mov 	$a2, $s0 # pass style (black bg, white fg)
				jal 	prnt
				add   $s1, $s2 # increment position
				addi  $s3, 1   # increment counter
				
        bnei  $s3, 1, menu2
				li $t1, info_text
				jl menu_loop
menu2:	bnei  $s3, 2, menu3
				li $t1, current_cond_text
				jl menu_loop			
menu3:	bnei  $s3, 3, menu4
				li $t1, hist_report_text
				jl menu_loop
menu4:	bnei  $s3, 4, menu_done
				li $t1, game_text
				jl menu_loop				
				
menu_done: pop $ra
				jr $ra
				
				
draw_info: li    $s0, blk_bg_h_red_fg
				li    $s1, title
				li    $s2, menu_text_off_strt
				li    $s3, 0 # counter
				li    $t1, info_text
				push  $ra
				
				# print info title
info_loop: mov $a0, $t1 # pass text to print
				mov   $a1, $s1 # pass position to print to
				mov 	$a2, $s0 # pass style (black bg, white fg)
				jal 	prnt
				add   $s1, $s2 # increment position
				addi  $s3, 1   # increment counter
				
        bnei  $s3, 1, info2
				li $s0, blk_bg_h_blu_fg
				li $t1, info1_text
				jl info_loop
info2:	bnei  $s3, 2, info3
				li $s0, blk_bg_h_grn_fg
				li $t1, info2_text
				jl info_loop			
info3:	bnei  $s3, 3, info4
				li $s0, blk_bg_h_ylw_fg
				li $t1, info3_text
				jl info_loop
info4:	bnei  $s3, 4, info_done
				li $s0, blk_bg_h_cyn_fg
				li $t1, info4_text
				jl info_loop				
				
info_done: pop $ra
				jr $ra


# waits the specified time where $a0 is the outer loop max value and $a1 is the inner loop max value
wait:   li    $t1, 0 # inner loop counter
oreset:	li    $t0, 0 # outer loop counter
oloop:	addi  $t0, 1
				beq  $t0, $a0, iloop # if $t0 == $a0 then increment inner loop
				jl    oloop # loop


iloop:	addi  $t1, 1
				beq  $t1, $a1, wait_done
				jl    oreset
wait_done: jr $ra


# takes pointer to first menu item ($a1), offset between menu items ($a0),
# and number of menu items to clear ($a2) and clears it with menu_itm_text_len 
# of menu_itm_blank's
clr_menu_text: li $s2, 0
							 mov $s0, $a0 # offset
							 mov $s1, $a2 # menu items to clear
clr_menu_loop: blt $s2, $s1, clr_menu_item
							 jr $ra
clr_menu_item: li $a0, menu_itm_blank
							 read $a0, $a0, 0 # get char
							 li $a2, menu_itm_text_len # const
							 push $ra # store $ra on stack
							 jal prnt_n_chars
							 pop $ra # restore $ra off stack
							 add $a1, $s0
							 addi $s2, 1
							 jl clr_menu_loop


# takes pointer to first divider ($a1), offset between dividers ($a0), 
# and number of dividers to draw ($a2) and draws left ($sp+2), center ($sp+1)
# and right ($sp) dividers
draw_dividers: mov  $s0, $a0 # save args, $s0 = offset between dividers
							mov   $s1, $a2 # $s1 = number of dividers to draw
							pop   $s2 # right divider
							pop   $s3 # center divider
							pop   $t0 # left divider
draw_div_loop: bnei  $s1, 0, draw_div
							jr    $ra
draw_div:     read  $t1, $t0, 0
							write $t1, $a1, 0
							addi  $a1, 1 # increment vga screen pointer + 1
							read  $a0, $s3, 0
							li    $a2, divider_c_num # num of chars to print
							push  $ra
							push  $t0
							jal   prnt_n_chars
							pop   $t0
							pop   $ra
							read  $t1, $s2, 0
							write $t1, $a1, 0
							add   $a1, $s0 # move vga pointer to next divider
							subi  $s1, 1 # decrement dividers drawn so far
							jl    draw_div_loop


# prints the specified char ($a0) n times ($a2) to the vga screen 
# starting at the position pointed to by $a1
# arguments
#			$a0 char to print
#			$a1 vga screen position to print char
#			$a2 number of chars to print in a row
# return void
prnt_n_chars:	bnei  $a2, 0, prnt_char
							jr    $ra
prnt_char:    write $a0, $a1, 0
							subi  $a2, 1 # decrement chars to print
							addi  $a1, 1 # print to the next location
							jl    prnt_n_chars

# prints string pointed to at $a0 to vga screen at location $a1
# with style $a2. Strings should be null terminated to prevent printing forever!
prnt:			 read  $t2, $a0, 0 	# get char
					 beqi  $t2, 0, prnt_done # if char is null pointer, finish
					 li    $t3, 0x00FF
					 and   $t2, $t3     # clear previous style
					 or    $t2, $a2		  # apply new style 
					 write $t2, $a1, 0 	# write char to screen
					 addi  $a0, 1 				# increment pointer address
					 addi  $a1, 1 				# increment vga location
					 jl    prnt
prnt_done: jr 	 $ra


# makes a char style given a blink ($a0), bg color ($a1), and fg color ($a2)
make_style: slli $a0, 3
						or   $a0, $a1  # combine blink with bg color
						slli $a0, 4
						or	 $a0, $a2  # combine blink, bg with fg color
						slli $a0, 8    # shift style to upper bits
						mov  $ret, $a0 # set return reg
						jr   $ra
