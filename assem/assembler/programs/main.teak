# prints a global string variable to the screen

.screen_init: init/main_screen.txt # 128x64 = 8192

.glyph_init: ascii_8x8_ext.png # 256x4 = 1024

.data 
			# !assembler important!
			SP_START:  .const 0x4fff # beginning addres of stack pointer (one less than stack memory to account for initial +1 first time push is called)
			
			# general
			TITLE: 		      .const 0xc1f	# TITLE + 1*0x200 = menu_itm1, +2*0x200 = menu_itm2, etc.
			DIVIDER:        .const 0xf13 # DIVIDER + 1*0x200 = DIVIDER2, etc.
			CURSOR_START:   .const 0xe1f # starts at first menu item
			DIVIDER_C_NUM:  .const 39  # number of center DIVIDER characters to draw
			DIVIDER_OFFSET: .const 472 # offset between DIVIDERs (last char to first char)
			MENU_ITM_TXT_LEN:  .const 18
			MENU_TXT_OFFSET:   .const 494 # offset between menu text (last char to first char)
			MENU_TXT_OFF_STRT: .const 512 # (first char to first char)
			MENU_ITM_BLANK:    .const 0x20 # space
			cursor_pos:  0 # 0 = item0, 1 = item1, 2 = item2, 3 = item3
			screen:      0 # 0 = menu, 1 = info, 2 = current cond, 3 = historical report, 4 = game?
			hours:       0 # for global clock, min 1, max 12
			minutes:     0 # for global clock, min 0, max 59
			seconds:     0 # for global clock, min 0, max 59
			blank_divider_r:   "´" # right DIVIDER character, vertical bar
			blank_divider_l:	 "¸" # left DIVIDER character, vertical bar
			blank_divider_c:   " " # center DIVIDER character, space
			line_divider_r:    "º" # right DIVIDER character, vertical bar w/ horizontal bar
			line_divider_l:    "¹" # left DIVIDER character, vertical bar w/ horizontal bar
			line_divider_c:    "»" # center DIVIDER character, horizontal bar
			menu_title:     	 "      Menu"
			info_text: 				 "      Info"
			current_cond_text: "Current Conditions"
			hist_report_text:  "Historical Report"
			game_text: 				 "      Game?"
			
			# info
			info1_text:        "Weather Station by"
			info2_text:        "E Oguz, T Dorney,"
			info3_text:        "K Bastakoti, &"
			info4_text:        "A Payne"
			
			# current conditions
			PTR_TEMPERATURE: .const 0x102c # pointer to area of vga to print to
			PTR_HUMIDITY:    .const 0x122c # pointer to area of vga to print to
			farenheit:   0 # boolean indicating which unit to show (C or F), 0 = C, 1 = F !UNIMPLEMENTED!
			temperature: 34
			humidity:    71
			str_temperature: "22 °C" # space for temp (max 3 digits), degree symbol, temp unit, & null terminator
			str_humidity:    "75  %" # space for humid (max 3 digits), percent symbol, & null terminator
			temperature_text:	 "Temperature:"
			humidity_text:     "Humidity:"
			
			# I/O
			BTN_SW_PTR:    .const 0x4c00 # address of buttons/switches input
			BTN_UP_MASK:   .const 0x0001 #  1 = 0..0000 0001
			BTN_RGHT_MASK: .const 0x0002 #  2 = 0..0000 0010
			BTN_DWN_MASK:  .const 0x0004 #  4 = 0..0000 0100
			BTN_LFT_MASK:  .const 0x0008 #  8 = 0..0000 1000
			BTN_CNTR_MASK: .const 0x0010 # 16 = 0..0001 0000
			
			# color styles
			BLK_BG_H_BLU_FG:   .const 0x0900
			BLK_BG_H_GRN_FG:   .const 0x0A00
			BLK_BG_H_CYN_FG:   .const 0x0B00
			BLK_BG_H_RED_FG:   .const 0x0C00
			BLK_BG_H_YLW_FG:   .const 0x0E00
			BLK_BG_WHITE_FG:   .const 0x0F00 
			
			# historical report
			HIST_DATA_LEN:     .const 11 # length of hist_data array
			HIST_GRAPH_PTR:    .const 0x1399 # pointer to first x position to draw to
			DST_BTWN_AXIS_LABELS: .const 3 # characters from one x axis label to the next
			Y_AXIS_STEP_SIZE:  .const 3 # 3 degrees
			X_AXIS_STEP_SIZE:  .const 1 # 1 minute
			MENU_STRT:         .const 0x0D93 # vga address of top left menu character (outside border)
			LINE_OFFSET:       .const 88  # last char to first char
			NUM_MENU_LINES:    .const 15 # num of lines in menu area (not including title bar)
			MENU_TOP_LEFT:     .const 0x0D94 # vga address of top left menu character (inside border)
			HIST_LINE_OFFSET:  .const 128 # first char to first char
			AXIS_TXT_WIDTH:    .const 5 # string width (including null terminator) of hist_y1_axis, hist_y2_axis, etc.
			HIST_LOW_PT:       .const 0x0cbc # lower dot (char), blk_bg_h_red_fg
			hist_data:     {22, 23, 24, 20, 18, 20, 25, 27, 29, 30, 31} # 11 data points (11 mins)
			hist_y13_axis: "  36"
			hist_y12_axis: "T   "
			hist_y11_axis: "e 30"
			hist_y10_axis: "m   "
			hist_y9_axis:  "p 24"
			hist_y8_axis:  "e   "
			hist_y7_axis:  "r 18"
			hist_y6_axis:  "a   "
			hist_y5_axis:  "t 12"
			hist_y4_axis:  "u   "
			hist_y3_axis:  "r  6"
			hist_y2_axis:  "e   "
			hist_y1_axis:  "   0"
			hist_x_axis:   "     0  1  2  3  4  5  6  7  8  9  10"
			hist_x_label:  "              Time (min)"
			
			

.teak # beginning of assembly code

# main program entry point
main:		jal initialize

				li    $a0, BLK_BG_H_RED_FG
				jal   sh_cursor
				
				# press down button
				jal   wait1sec 
				li    $a0, BTN_DWN_MASK
				jal   press_btn
				
				jal   chk_scrn
				
				# press center button (view current cond)
				jal   wait1sec 
				li    $a0, BTN_CNTR_MASK
				jal   press_btn
				
				jal   chk_scrn
				
				# press back button
				jal   wait1sec 
				li    $a0, BTN_LFT_MASK
				jal   press_btn
				
				jal   chk_scrn
				
				# press up button
				jal   wait1sec 
				li    $a0, BTN_UP_MASK
				jal   press_btn
				
				jal   chk_scrn
				
				# press center button (view info)
				jal   wait1sec 
				li    $a0, BTN_CNTR_MASK
				jal   press_btn
				
				jal   chk_scrn
				
				# press back button
				jal   wait1sec 
				li    $a0, BTN_LFT_MASK
				jal   press_btn
				
				jal   chk_scrn
				
				# press down button
				jal   wait1sec 
				li    $a0, BTN_DWN_MASK
				jal   press_btn
				
				jal   chk_scrn
				
				# press down button
				jal   wait1sec 
				li    $a0, BTN_DWN_MASK
				jal   press_btn
				
				jal   chk_scrn
				
				# press center button (view historical report)
				jal   wait1sec 
				li    $a0, BTN_CNTR_MASK
				jal   press_btn
				
				jal   chk_scrn
				
				jal wait1sec
				
				jal   chk_scrn
				
				# press back button
				jal   wait1sec 
				li    $a0, BTN_LFT_MASK
				jal   press_btn
				
				jal   chk_scrn				
				
while:  jl main


# simulate btn presses. $a0 is the button to press (use mask)
press_btn: li $t0, BTN_SW_PTR
					 write $a0, $t0, 0
					 jr $ra


# explicitly clears all registers and sets $sp. Also runs 
# the clk for ~65,000 cycles in order allow cpu to stabalize.
# arguments
#			none
# returns void
initialize: li $a0, TITLE
						li $a1, 0
						li $a2, 0
						li $s0, 0
						li $s1, 0
						li $s2, 0
						li $s3, 0
						li $t0, 0 
						li $t1, 0
						li $t2, 0
						li $t3, 0
						li $ret, TITLE
						li $sp, SP_START # initialize stack pointer address
						li $at, 0
						
						li $a0, 65000
init_loop:  beqi $a0, 0, init_done
						subi $a0, 1
						jl init_loop
init_done:  li $a0, 0
						jr $ra
						

# chk_scrn: check screen [state]
# checks what screen is currently displayed and calls the appropriate
# button checker and update functions
# arguments
#			none
# returns void						
chk_scrn: 	li   $t0, screen
						read $t2, $t0, 0 # get current screen state
						push $ra # save $ra away
						
						bnei $t2, 0, chk_info
						jal  chk_btns_menu
						jl   chk_scrn_done
chk_info:	  bnei $t2, 1, chk_cond
						jal  chk_btns_oth
						jl   chk_scrn_done
chk_cond:		bnei $t2, 2, chk_hist
						jal  update_cond
						jal  chk_btns_oth
						jl   chk_scrn_done
chk_hist:	  bnei $t2, 3, chk_scrn_done
						jal  plot_data
						jal  chk_btns_oth
chk_scrn_done:   pop  $ra
						jr   $ra
						
					
# plot_data
# plots the historical data stored in hist_data onto the 
# historical report graph
# arguments
#			none
# returns void	
plot_data: li $s0, hist_data # pointer to first int in array
					 li $s1, HIST_GRAPH_PTR
					 li $s2, HIST_DATA_LEN # number of times to loop
					 li $s3, HIST_LINE_OFFSET
					 push $ra 
					 
plot_ol:	 mov $a1, $s1
					 read $t0, $s0, 0 # get value
plot_il:	 subi $t0, Y_AXIS_STEP_SIZE
					 blti $t0, 0, plot_draw
					 sub  $a1, $s3 # move up one data section
					 jl   plot_il
					 
plot_draw: addi $t0, Y_AXIS_STEP_SIZE # restore
					 li   $a0, HIST_LOW_PT # load base data point
					 add  $a0, $t0 # offset up to display point higher in 8x8 tile
					 li   $a2, 1 # print one char
					 jal prnt_n_chars
					 subi $s2, 1
					 beqi $s2, 0, plot_d
					 addi $s1, DST_BTWN_AXIS_LABELS # increment to next x axis label
					 addi $s0, 1 # move to next value in array
					 jl   plot_ol
					 
plot_d:		 pop $ra
					 jr   $ra


# update_cond: update [current] conditions
# retrieves the current temperature and humidity (integers) and converts
# both to strings. finally, each is printed to the screen
# arguments
#			none
# returns void						
update_cond: li $a0, temperature # convert temperature to string
						 read $a0, $a0, 0
						 li $a1, str_temperature
						 push $ra
						 jal itos
						 
						 # convert humidity to string
						 li $a0, humidity
						 read $a0, $a0, 0
						 li $a1, str_humidity
						 jal itos
						 
						 # print temperature
						 li $a0, str_temperature
						 li $a1, PTR_TEMPERATURE
						 li $a2, BLK_BG_WHITE_FG
						 jal prnt
						 
						 # print humidity
						 li $a0, str_humidity
						 li $a1, PTR_HUMIDITY
						 li $a2, BLK_BG_WHITE_FG
						 jal prnt
						 
						 pop $ra
						 jr $ra
						 
						

# chk_btns_menu: check button [states in] menu [screen]
# checks the state of the buttons while the menu screen is being displayed
# and performs the appropriate action depending on the current cursor
# position
# arguments
#			none 
# returns void					
chk_btns_menu: li $t0, BTN_SW_PTR
						read $t1, $t0, 0 # get current state of btns
						push $ra
						
 						li  $t0, BTN_CNTR_MASK # check center button first
	 					mov $t3, $t0 # keep mask around
						and $t3, $t1 # get state of center btn
						beq $t3, $t0, btn_c_mon
						
						li  $t0, BTN_UP_MASK
						mov $t3, $t0 # keep mask around
						and $t3, $t1 # get state of center btn
						beq $t3, $t0, btn_up_mon
						
						li  $t0, BTN_DWN_MASK
						mov $t3, $t0 # keep mask around
						and $t3, $t1 # get state of center btn
						beq $t3, $t0, btn_dwn_mon
						jl  chk_btns_mdone
						
btn_c_mon:  li   $t2, cursor_pos
						read $t2, $t2, 0 # get cursor position
						bnei $t2, 0, btn_cmc
						jal draw_info
						jl  chk_btns_mdone
btn_cmc:    bnei $t2, 1, btn_cmh
						jal draw_cond
						jl chk_btns_mdone
btn_cmh:    bnei $t2, 2, chk_btns_mdone
						jal draw_hist
						jl chk_btns_mdone

btn_up_mon: li $a0, 0 # increment cursor
						jal mov_cursor
						jl chk_btns_mdone
						
btn_dwn_mon: li $a0, 1 # decrement cursor
						jal mov_cursor				
						
chk_btns_mdone: pop $ra
						jr $ra
						
# chk_btns_other: check button [states in] other [screens]
# checks the state of the buttons while the other screens are being displayed. 
# this is primarily for any screen that only registers the "back" (left btn)
# press (which then draws the menu)
# arguments
#			none 
# returns void						
chk_btns_oth: li $t0, BTN_SW_PTR
						read $t1, $t0, 0 # get current state of btns
						push $ra
						
 						li  $t0, BTN_LFT_MASK # check center button first
	 					mov $t3, $t0 # keep mask around
						and $t3, $t1 # get state of center btn
						beq $t3, $t0, btn_l_oon
						jl  chk_btns_odone
						
btn_l_oon:  jal draw_menu				
						
chk_btns_odone: pop $ra
						jr $ra


# sh_cursor: show/hide cursor
# colors the text at the current cursor position with style $a0
# arguments
#			$a0 style with which to color cursor
# returns void
sh_cursor:   mov   $a2, $a0 # put cursor style in proper reg
						 li    $t0, cursor_pos
						 read  $t1, $t0, 0 # get cursor position
						 li    $a0, CURSOR_START # address of first cursor position 
						 li    $t3, MENU_TXT_OFF_STRT
cursor_loop: beqi  $t1, 0, color_cursor
						 add   $a0, $t3 # go to next cursor position
						 subi  $t1, 1
						 jl    cursor_loop
color_cursor: li   $a1, MENU_ITM_TXT_LEN # number of chars to highlight
						 push  $ra
						 jal   style_n_chars # color cursor
						 pop   $ra
						 jr 	 $ra


# mov_cursor: move cursor (up or down)
# increments or decrements the cursor position. keeps cursor from
# incrementing/decrementing too far. Also handles clearing style on current
# cursor position and updating next cursor position
# arguments
#			$a0 decrement? (boolean indicating 0 = increment or 1 = decrement)
# returns void
mov_cursor: mov  $s0, $a0 # save decrement
						li   $a0, BLK_BG_WHITE_FG
						push $ra
						jal  sh_cursor # hide current cursor
						li   $t0, cursor_pos
						read $t1, $t0, 0 # get cursor position
						beqi $s0, 0, decr
						beqi $t1, 3, wrap_to_strt
						addi $t1, 1
						jl   movc_fin
decr:				beqi $t1, 0, wrap_to_end
						subi $t1, 1
						jl   movc_fin
wrap_to_strt: li $t1, 0
						jl   movc_fin
wrap_to_end: li  $t1, 3
movc_fin:   write $t1, $t0, 0
						li   $a0, BLK_BG_H_RED_FG
						jal  sh_cursor
						pop  $ra
						jr  $ra
						
						
# draw_hist: draw historical [report screen]
# arguments
#			none
# returns void
draw_hist: li $a0, MENU_TXT_OFFSET # MENU_TXT_OFFSET
				li    $a1, TITLE # starting with TITLE
				li    $a2, 5 # clear 5 menu items
				push  $ra
				jal 	clr_menu_text
				
				# clear DIVIDERs
				li    $a0, DIVIDER_OFFSET
				li    $a1, DIVIDER
				li    $a2, 3 # clear 3 DIVIDERs
				li    $t0, blank_divider_l
				li    $t1, blank_divider_c
				li    $t2, blank_divider_r
				push  $t0
				push  $t1
				push  $t2
				jal 	draw_dividers
				
				# print title
				li    $a0, hist_report_text
				li    $a1, TITLE
				li    $a2, BLK_BG_WHITE_FG
				jal   prnt

				li    $s0, BLK_BG_H_BLU_FG # style
				li    $s1, MENU_TOP_LEFT # location to start drawing
				li    $s2, HIST_LINE_OFFSET # offset between menu items (first char to first char)
				li    $s3, hist_y13_axis # first string to print
				li    $t0, hist_x_axis # string on which to stop printing (sequentially)
				
				# print y axis labels
hist_l: mov   $a0, $s3 # pass text to print
				mov   $a1, $s1 # pass position to print to
				mov 	$a2, $s0 # pass style (black bg, white fg)
				push  $t0 # need to save for after call
				jal 	prnt
				pop   $t0
				add   $s1, $s2 # increment position
hist_y:	beq   $s3, $t0, hist_x
				addi  $s3, AXIS_TXT_WIDTH # increment to the next y axis string (relying on the fact that all the y axis strings are stored sequentially)
				jl hist_l
				
hist_x:	li    $a0, hist_x_label
				mov   $a1, $s1
				mov   $a2, $s0
				jal   prnt
				
hist_fin: li  $t0, screen # address of screen counter
				li    $t1, 3 # set screen state to historical report
				write $t1, $t0, 0 # set screen counter to 0
				
				jal plot_data # plot data before returning
				
				pop   $ra
				jr    $ra

# draw_cond: draw [current] conditions screen
# arguments
#			none
# returns void
draw_cond: li    $a0, MENU_TXT_OFFSET # MENU_TXT_OFFSET
				li    $a1, TITLE # starting with TITLE
				li    $a2, 5 # clear 5 menu items
				push  $ra
				jal 	clr_menu_text
				
				# clear DIVIDERs
				li    $a0, DIVIDER_OFFSET
				li    $a1, DIVIDER
				li    $a2, 3 # clear 3 DIVIDERs
				li    $t0, blank_divider_l
				li    $t1, blank_divider_c
				li    $t2, blank_divider_r
				push  $t0
				push  $t1
				push  $t2
				jal 	draw_dividers

				li    $s0, BLK_BG_WHITE_FG # style
				li    $s1, TITLE # location to start drawing
				li    $s2, MENU_TXT_OFF_STRT # offset between menu items (first char to first char)
				li    $s3, 0 # counter
				li    $t1, current_cond_text # TITLE string
				
cond_loop: mov $a0, $t1 # pass text to print
				mov   $a1, $s1 # pass position to print to
				mov 	$a2, $s0 # pass style (black bg, white fg)
				jal 	prnt
				add   $s1, $s2 # increment position
				addi  $s3, 1   # increment counter
				
        bnei  $s3, 1, cond2
				li    $t1, temperature_text
				add   $s1, $s2 # skip first item slot
				jl    cond_loop
cond2:	bnei  $s3, 2, cond3
				li    $t1, humidity_text
				jl    cond_loop
cond3:  bnei  $s3, 3, cond4
				li $t1, str_temperature
				li $s1, PTR_TEMPERATURE
				jl    cond_loop
cond4:  bnei  $s3, 4, cond_done
				li $t1, str_humidity
				li $s1, PTR_HUMIDITY
				jl    cond_loop
				
cond_done: li $t0, screen # address of screen counter
				li    $t1, 2 # set screen state to current conditions
				write $t1, $t0, 0 # set screen counter to 0
				pop   $ra
				jr    $ra


# draw_menu: draw menu [screen]
# arguments
#			none
# returns void
draw_menu: li $a0, 0 # MENU_TXT_OFFSET
				li    $a1, TITLE # starting with TITLE
				li    $a2, 1 # clear title
				push  $ra
				jal 	clr_menu_text
				
				jal   clr_menu # clear entire menu space
				
				li    $a0, DIVIDER_OFFSET
				li    $a1, DIVIDER
				li    $a2, 3 # draw 3 DIVIDERs
				li    $t0, line_divider_l
				li    $t1, line_divider_c
				li    $t2, line_divider_r
				push  $t0 # extra args go on stack
				push  $t1
				push  $t2
				jal 	draw_dividers
				
				li 		$s0, BLK_BG_WHITE_FG
				li    $s1, TITLE
				li    $s2, MENU_TXT_OFF_STRT
				li    $s3, 0 # counter
				li    $t1, menu_title
				
menu_loop: mov $a0, $t1 # pass text to print
				mov   $a1, $s1 # pass position to print to
				mov 	$a2, $s0 # pass style (black bg, white fg)
				jal 	prnt
				add   $s1, $s2 # increment position
				addi  $s3, 1   # increment counter
				
        bnei  $s3, 1, menu2
				li $t1, info_text
				jl menu_loop
menu2:	bnei  $s3, 2, menu3
				li $t1, current_cond_text
				jl menu_loop			
menu3:	bnei  $s3, 3, menu4
				li $t1, hist_report_text
				jl menu_loop
menu4:	bnei  $s3, 4, menu_done
				li $t1, game_text
				jl menu_loop				
				
menu_done: li $t0, screen # address of screen counter
				li    $t1, 0
				write $t1, $t0, 0 # set screen counter to 0
				li    $a0, BLK_BG_H_RED_FG
				jal   sh_cursor
				pop $ra
				jr $ra


# draw_info
# draws the info screen
# arguments
#			none
# returns void
draw_info: li    $a0, MENU_TXT_OFFSET # MENU_TXT_OFFSET
				li    $a1, TITLE # starting with TITLE
				li    $a2, 5 # clear 5 menu items
				push  $ra
				jal 	clr_menu_text
				
				li    $a0, DIVIDER_OFFSET
				li    $a1, DIVIDER
				li    $a2, 3 # clear 3 DIVIDERs
				li    $t0, blank_divider_l
				li    $t1, blank_divider_c
				li    $t2, blank_divider_r
				push  $t0
				push  $t1
				push  $t2
				jal 	draw_dividers

				li    $s0, BLK_BG_H_RED_FG
				li    $s1, TITLE
				li    $s2, MENU_TXT_OFF_STRT
				li    $s3, 0 # counter
				li    $t1, info_text
				
				# print info TITLE
info_loop: mov $a0, $t1 # pass text to print
				mov   $a1, $s1 # pass position to print to
				mov 	$a2, $s0 # pass style (black bg, white fg)
				jal 	prnt
				add   $s1, $s2 # increment position
				addi  $s3, 1   # increment counter
				
        bnei  $s3, 1, info2
				li $s0, BLK_BG_H_BLU_FG
				li $t1, info1_text
				jl info_loop
info2:	bnei  $s3, 2, info3
				li $s0, BLK_BG_H_GRN_FG
				li $t1, info2_text
				jl info_loop			
info3:	bnei  $s3, 3, info4
				li $s0, BLK_BG_H_YLW_FG
				li $t1, info3_text
				jl info_loop
info4:	bnei  $s3, 4, info_done
				li $s0, BLK_BG_H_CYN_FG
				li $t1, info4_text
				jl info_loop				
				
info_done: li $t0, screen # address of screen counter
				li $t1, 1
				write $t1, $t0, 1 # set screen counter to 0
				pop $ra
				jr $ra


# wait
# waits the specified time where $a0 is the outer loop max value 
# and $a1 is the inner loop max value
# arguments
#			$a0 inner loop max value
#			#a1 outer loop max value
# returns void
wait:   li    $t1, 0 # inner loop counter
oreset:	li    $t0, 0 # outer loop counter
oloop:	addi  $t0, 1
				beq  $t0, $a0, iloop # if $t0 == $a0 then increment inner loop
				jl    oloop # loop


iloop:	addi  $t1, 1
				beq  $t1, $a1, wait_done
				jl    oreset
wait_done: jr $ra

# wait1sec: wait 1 second
# arguments
#			none
# returns void
wait1sec: li 	$a0, 65000 # outer loop limit, 65000*150 ~= 1 sec wait
				li 		$a1, 300 # inner loop limit
				li    $t1, 0 # inner loop counter
w1oreset: li  $t0, 0 # outer loop counter
w1oloop: addi $t0, 1
				beq   $t0, $a0, iloop # if $t0 == $a0 then increment inner loop
				jl    oloop # loop


w1iloop: addi $t1, 1
				beq  $t1, $a1, wait_done
				jl   oreset
wait1_done: jr $ra


# clr_menu_text: clear menu text
# takes pointer to first menu item ($a1), offset between menu items ($a0),
# and number of menu items to clear ($a2) and clears it with MENU_ITM_TXT_LEN 
# of MENU_ITM_BLANK's
# arguments
#			$a0 offset between menu items (last char to first char)
#			$a1 first menu item to clear
#			$a2 number of menu items to clear
# returns void
clr_menu_text: mov $s0, $a0 # offset
							 mov $s1, $a2 # menu items to clear
clr_menu_loop: beqi $s1, 0, clr_menu_item
							 jr $ra
clr_menu_item: li $a0, MENU_ITM_BLANK
							 li $a2, MENU_ITM_TXT_LEN # const
							 push $ra # store $ra on stack
							 jal prnt_n_chars
							 pop $ra # restore $ra off stack
							 add $a1, $s0
							 subi $s1, 1
							 jl clr_menu_loop
							 

# clr_menu: clear menu
# clears the entire menu area of all text
# arguments
#			none
# returns void
clr_menu: li    $a0, LINE_OFFSET 
					li    $a1, MENU_STRT 
					li    $a2, NUM_MENU_LINES # clear all lines in menu
					li    $t0, blank_divider_l
					li    $t1, blank_divider_c
					li    $t2, blank_divider_r
					push  $ra
					push  $t0
					push  $t1
					push  $t2
					jal   draw_dividers
					pop   $ra
					jr    $ra
					


# draw_dividers
# takes pointer to first divider ($a1), offset between dividers ($a0), 
# and number of dividers to draw ($a2) and draws left ($sp+2), center ($sp+1)
# and right ($sp) dividers
# arguments
#			$a0   offset between dividers (last char to first char)
#			$a1   pointer to first dividers
#			$a2   number of dividers to draw
#			$sp   pointer to right divider character
#			$sp+1 pointer to center divider character
#			$sp+2 pointer to left divider character
# returns void
draw_dividers: mov  $s0, $a0 # save args, $s0 = offset between dividers
							mov   $s1, $a2 # $s1 = number of dividers to draw
							pop   $s2 # right divider
							pop   $s3 # center divider
							pop   $t0 # left divider
draw_div_loop: bnei  $s1, 0, draw_div
							jr    $ra
draw_div:     read  $t1, $t0, 0
							write $t1, $a1, 0 # draw left divider
							addi  $a1, 1 # increment vga screen pointer + 1
							read  $a0, $s3, 0
							li    $a2, DIVIDER_C_NUM # num of chars to print
							push  $ra
							push  $t0
							jal   prnt_n_chars
							pop   $t0
							pop   $ra
							read  $t1, $s2, 0
							write $t1, $a1, 0
							add   $a1, $s0 # move vga pointer to next divider
							subi  $s1, 1 # decrement dividers drawn so far
							jl    draw_div_loop


# prnt_n_chars: print n characters
# prints the specified char ($a0) n times ($a2) to the vga screen 
# starting at the position pointed to by $a1
# arguments
#			$a0 char to print
#			$a1 vga screen position to print char
#			$a2 number of chars to print in a row
# returns void
prnt_n_chars:	bnei  $a2, 0, prnt_char
							jr    $ra
prnt_char:    write $a0, $a1, 0
							subi  $a2, 1 # decrement chars to print
							addi  $a1, 1 # print to the next location
							jl    prnt_n_chars


# prnt: print
# prints string pointed to at $a0 to vga screen at location $a1
# with style $a2. Strings should be null terminated to prevent printing forever!
# arguments
#			$a0 string to print (pointer to first char)
#			$a1 vga screen location to print to
#			$a2 style to apply to string
# returns void
prnt:			 read  $t2, $a0, 0 	# get char
					 beqi  $t2, 0, prnt_done # if char is null pointer, finish
					 li    $t3, 0x00FF
					 and   $t2, $t3     # clear previous style
					 or    $t2, $a2		  # apply new style 
					 write $t2, $a1, 0 	# write char to screen
					 addi  $a0, 1 				# increment pointer address
					 addi  $a1, 1 				# increment vga location
					 jl    prnt
prnt_done: jr 	 $ra


# style_n_chars: style n characters
# applys the style provided in $a2 to the string pointed to by $a0
# for the number of characters specified in $a1. This proc is meant to be used
# to dynamically style characters already on screen but can be used for any 
# character set stored anywhere in memory
# arguments
#			$a0 pointer to first char to which to apply style
#			$a1 number of characters to style
#			$a2 style to apply
# returns void
style_n_chars: beqi $a1, 0, style_done
					 read  $t0, $a0, 0 # get char
					 li    $t2, 0x00FF
					 and   $t0, $t2     # clear previous style
					 or    $t0, $a2 # apply style
					 write $t0, $a0, 0 # write char to screen
					 subi  $a1, 1 # subtract num of chars to style
					 addi  $a0, 1 # increment to next char
					 jl    style_n_chars
style_done: jr   $ra


# make_style
# makes a char style given a blink ($a0), bg color ($a1), and fg color ($a2)
# arguments
#			$a0 blink (0 = no blink, 1 = blink)
#			$a1 background color (3 bit)
#     $a2 foreground color (4 bit)
# returns style (upper 8 bits of $ret set per $a0, $a1, $a2)
make_style: slli $a0, 3
						or   $a0, $a1  # combine blink with bg color
						slli $a0, 4
						or	 $a0, $a2  # combine blink, bg with fg color
						slli $a0, 8    # shift style to upper bits
						mov  $ret, $a0 # set return reg
						jr   $ra
								
						
# itos: integer to string
# converts an integer value ($a0) into a string, pointed at by $a1
# arguments. Note that the max value that can be converted is (2^15)-1
#			$a0 integer to convert into a string
#			$a1 pointer to string to store converted integer
# returns void						
itos:	li   $t2, 10000 # $t2 = decimal position current converting
			li   $t0, 1 # assume leading zero to begin with
			li 	 $t1, 0 # control variable
itos_loop: li   $ret, 0 # zero out $ret

chk_pos: comp  $a0,  $t2 # $a0 - $t2, $a0 <=? $t2
			jlt  chk_done # use comp then jlt because in most cases will keep subtracted value
			addi 	$ret, 1
			jl 		chk_pos

chk_done: add 	$a0, $t2 # restore $a0
			beqi  $t0, 0, store # check if base 10 position is leading zero and don't store if it is
			beqi  $ret, 0, dont_store
			li    $t0, 0
store: addi  $ret, 48   # get ascii code
			 write $ret, $a1, 0  # store ascii code into number address
			 addi 	$a1, 1	# increment mem address
dont_store: addi  $t1, 1

# case structure to determine decimal position to work on
   			 bnei $t1, 1, set_100 
			   li $t2, 1000
			   jl itos_loop
set_100: bnei $t1, 2, set_10
			   li $t2, 100
			   jl itos_loop
set_10:	 bnei $t1, 3, set_1
				 li $t2, 10
			 	 jl itos_loop
set_1:   bnei $t1, 4, itos_done
				 li $t2, 1
			   jl itos_loop 

itos_done: jr $ra


# ctof: celcius to farenheit
# converts the given celcius value ($a0) into farenheit. Approximate value returned,
# because floating point multiplication is unsupported. Instead a bit shift
# by 1 (*2) is used rather than a multiplication by 1.8.
# arguments
#			$a0 celcius value to converts
# returns farenheit value
ctof: slli $a0, 1
			addi $a0, 32
			mov  $ret, $a0
			jr   $ra
